### **미션 제목**: 상속과 다형성을 이용한 캐릭터 클래스 구현

### **미션 내용**

게임의 다양한 캐릭터 직업을 클래스로 구현합니다. 모든 캐릭터의 기본이 되는 `Character` 부모 클래스를 먼저 정의합니다. 그 후, `Character` 클래스를 상속받는 `Warrior`와 `Mage` 자식 클래스를 각각 생성합니다.

각 직업은 부모의 기본 능력치(이름, 체력, 공격력)를 물려받으면서, 자신만의 고유한 속성과 공격 방식을 가집니다. 마지막으로, 생성된 여러 직업의 캐릭터 인스턴스를 하나의 리스트에 담아, 각자의 방식으로 동일한 대상을 공격하는 상황을 구현합니다.

### **미션 요구 사항**

1.  **`Character` (부모 클래스)**
    *   `__init__` 메서드에서 `name`, `hp`, `power` 세 가지 속성을 초기화합니다.
    *   `attack` 메서드는 `target`을 인자로 받아 "기본 공격"을 수행하며, 자신의 `power`만큼 `target`의 `hp`를 감소시킵니다. 공격 메시지를 출력해야 합니다.
    *   `show_status` 메서드는 현재 캐릭터의 이름, 체력, 공격력을 출력합니다.

2.  **`Warrior` (자식 클래스)**
    *   `Character` 클래스를 상속받습니다.
    *   `__init__` 메서드에서 `name`, `hp`, `power`와 더불어, 고유 속성인 `defense` (방어력)를 추가로 초기화합니다.
    *   부모 클래스의 `__init__`을 호출하기 위해 `super()`를 사용해야 합니다.
    *   `attack` 메서드를 **메서드 오버라이딩**하여 "강력한 베기 공격!"이라는 메시지를 출력하고, 자신의 `power`와 `defense`의 합만큼 `target`의 `hp`를 감소시키는 로직을 구현합니다.

3.  **`Mage` (자식 클래스)**
    *   `Character` 클래스를 상속받습니다.
    *   `__init__` 메서드에서 `name`, `hp`, `power`와 더불어, 고유 속성인 `mana` (마나)를 추가로 초기화합니다.
    *   부모 클래스의 `__init__`을 호출하기 위해 `super()`를 사용해야 합니다.
    *   `attack` 메서드를 **메서드 오버라이딩**하여, `mana`가 10 이상일 경우 "마법 공격!" 메시지와 함께 `power`의 2배만큼 피해를 주고 `mana`를 10 소모합니다. `mana`가 10 미만일 경우 "지팡이 공격" 메시지와 함께 `power`의 0.5배만큼 피해를 줍니다.

4.  **다형성 구현**
    *   `Warrior`, `Mage`, 그리고 기본 `Character` 인스턴스를 각각 하나씩 생성합니다.
    *   이 세 인스턴스를 하나의 리스트 `characters`에 담습니다.
    *   공격 대상이 될 `Monster` 인스턴스를 하나 생성합니다.
    *   `for` 반복문을 사용하여 `characters` 리스트를 순회하면서, 각 캐릭터가 `Monster`를 한 번씩 공격하도록 `attack` 메서드를 호출합니다.
    *   각 공격 전후로 `Monster`의 `show_status`를 호출하여 체력 변화를 확인합니다.

5.  **타입 힌트 적용**
    *   모든 `attack` 메서드의 `target` 매개변수에 `Character` 타입 힌트를 적용합니다. (예: `def attack(self, target: 'Character'):`)

---

---

### **미션 풀이**

이 미션은 객체 지향 프로그래밍의 핵심 개념인 상속, 메서드 오버라이딩, 다형성을 순서대로 구현하는 과정입니다. 아래 단계에 따라 해결할 수 있습니다.

1.  **기반 클래스 `Character` 정의**
    *   가장 먼저 모든 캐릭터의 공통 기반이 될 `Character` 클래스를 정의합니다.
    *   `__init__` 메서드에서는 `name`, `hp`, `power`를 인자로 받아 초기화합니다.
    *   `attack` 메서드는 `target`의 `hp`를 자신의 `power`만큼 감소시키는 기본 공격 로직을 구현합니다. 타입 힌트 `target: 'Character'`를 명시하여, 이 메서드가 `Character` 혹은 그 자식 클래스의 인스턴스를 인자로 받을 것임을 나타냅니다.
    *   `show_status`는 현재 상태를 출력하는 단순한 유틸리티 메서드입니다.

2.  **자식 클래스 `Warrior`와 `Mage` 정의**
    *   `class Warrior(Character):` 와 같이 소괄호 안에 부모 클래스명을 넣어 상속 관계를 설정합니다.
    *   각 자식 클래스의 `__init__` 메서드에서는 부모 클래스의 속성(`name`, `hp`, `power`)과 자신만의 고유 속성(`defense` 또는 `mana`)을 모두 인자로 받습니다.
    *   `super().__init__(name, hp, power)`를 호출하여 부모 클래스의 초기화 로직을 재사용합니다. 이는 코드 중복을 피하는 중요한 과정입니다. 그 후에 자식 클래스 고유의 속성을 초기화합니다.
    *   `attack` 메서드를 부모와 동일한 이름으로 다시 정의하여 **메서드 오버라이딩**을 구현합니다. `Warrior`는 `power`와 `defense`를 합친 피해를, `Mage`는 `mana` 상태에 따라 다른 피해를 주도록 직업 특성에 맞는 고유한 로직을 작성합니다.

3.  **다형성 시연 로직 구현**
    *   요구사항에 따라 `Warrior`, `Mage`, `Character` 클래스의 인스턴스를 각각 생성합니다.
    *   공격 대상이 될 `Monster`가 필요합니다. `Monster`는 공격을 받아 `hp`가 감소해야 하므로, `Character` 클래스와 동일한 구조를 가집니다. 따라서 `Monster` 역시 `Character`를 상속받아 간단히 구현할 수 있습니다.
    *   생성된 캐릭터 인스턴스(`warrior`, `mage`, `basic_char`)들을 하나의 리스트 `characters`에 담습니다. 이 리스트에는 서로 다른 타입의 객체들이 함께 저장됩니다.
    *   `for` 반복문으로 `characters` 리스트를 순회하며, 각 요소를 `unit`이라는 변수로 받습니다.
    *   `unit.attack(monster)`를 호출합니다. 파이썬 인터프리터는 `unit`이 현재 `Warrior`인지, `Mage`인지, 아니면 기본 `Character`인지를 스스로 판단하여 해당 객체의 타입에 맞는 `attack` 메서드를 실행합니다. 이것이 바로 **다형성**입니다.
    *   각 공격의 결과를 명확히 확인하기 위해, 공격 전후로 `monster.show_status()`를 호출하여 체력 변화를 출력합니다.

#### **최종 전체 소스코드**

```python
from __future__ import annotations

class Character:
    """모든 캐릭터의 기반이 되는 부모 클래스"""
    def __init__(self, name: str, hp: int, power: int):
        self.name = name
        self.hp = hp
        self.power = power
        print(f"{self.name}이(가) 생성되었습니다.")

    def attack(self, target: 'Character'):
        """
        대상에게 기본 공격을 수행합니다.
        자신의 power만큼 대상의 hp를 감소시킵니다.
        """
        print(f"<{self.name}>의 기본 공격!")
        target.hp -= self.power
        print(f"{target.name}에게 {self.power}의 피해를 입혔습니다.")

    def show_status(self):
        """캐릭터의 현재 상태를 출력합니다."""
        print(f"이름: {self.name}, 체력: {self.hp}, 공격력: {self.power}")

class Warrior(Character):
    """Character 클래스를 상속받는 전사 클래스"""
    def __init__(self, name: str, hp: int, power: int, defense: int):
        # 부모 클래스의 __init__ 메서드 호출
        super().__init__(name, hp, power)
        self.defense = defense  # 고유 속성인 방어력 추가

    def attack(self, target: 'Character'):
        """
        대상을 공격하는 메서드를 오버라이딩합니다.
        power와 defense의 합만큼 피해를 줍니다.
        """
        damage = self.power + self.defense
        print(f"<{self.name}>의 강력한 베기 공격!")
        target.hp -= damage
        print(f"{target.name}에게 {damage}의 피해를 입혔습니다.")

class Mage(Character):
    """Character 클래스를 상속받는 마법사 클래스"""
    def __init__(self, name: str, hp: int, power: int, mana: int):
        # 부모 클래스의 __init__ 메서드 호출
        super().__init__(name, hp, power)
        self.mana = mana  # 고유 속성인 마나 추가

    def attack(self, target: 'Character'):
        """
        대상을 공격하는 메서드를 오버라이딩합니다.
        mana 상태에 따라 다른 공격을 수행합니다.
        """
        if self.mana >= 10:
            damage = self.power * 2
            self.mana -= 10
            print(f"<{self.name}>의 마법 공격!")
            target.hp -= damage
            print(f"{target.name}에게 {damage}의 피해를 입히고, 마나 10을 소모했습니다. (남은 마나: {self.mana})")
        else:
            damage = self.power * 0.5
            print(f"<{self.name}>의 지팡이 공격! (마나 부족)")
            target.hp -= damage
            print(f"{target.name}에게 {int(damage)}의 피해를 입혔습니다.")

# --- 다형성 구현 ---

# 1. 각기 다른 클래스의 인스턴스 생성
warrior = Warrior(name="강철의 전사", hp=120, power=20, defense=10)
mage = Mage(name="지혜의 마법사", hp=80, power=25, mana=50)
basic_char = Character(name="초보 모험가", hp=100, power=15)

# 2. 인스턴스들을 하나의 리스트에 담기
characters = [warrior, mage, basic_char]

# 3. 공격 대상 몬스터 생성 (Character 클래스 재사용)
monster = Character(name="고블린", hp=200, power=10)

print("\n--- 전투 시작 ---")
monster.show_status()
print("-" * 20)

# 4. 반복문을 통해 각 캐릭터가 몬스터를 공격
for unit in characters:
    unit.attack(monster)
    monster.show_status()
    print("-" * 20)

print("--- 전투 종료 ---")
```