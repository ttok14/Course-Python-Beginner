### **미션 제목**: 용사(Hero) 클래스 구현 및 몬스터와의 상호작용

### **미션 내용**

수업에서 배운 `Monster` 클래스와 상호작용할 수 있는 `Hero` 클래스를 직접 정의합니다. `Hero` 클래스는 자신만의 속성(이름, 체력, 마력, 공격력)을 가지며, `Monster`를 공격하는 기능과 스스로를 치유하는 기능을 메서드로 구현해야 합니다.

정의한 `Hero` 클래스와 수업에서 사용한 `Monster` 클래스의 객체를 각각 생성한 후, 영웅이 몬스터를 공격하고 스스로를 치유하는 간단한 시나리오를 코드로 작성합니다.

### **미션 요구 사항**

1.  클래스의 이름은 `Hero`로 지정합니다.
2.  `__init__` 메서드에서 `name`, `hp`, `mp`(마력), `power`(공격력) 네 개의 인자를 받아 객체의 속성으로 초기화합니다.
3.  `__init__` 메서드 내에서 `hp`의 초기값을 저장하는 `max_hp` 속성을 추가로 생성합니다. 이 속성은 치유 시 최대 체력을 초과하지 않도록 검사하는 데 사용됩니다.
4.  `attack` 메서드를 정의합니다. 이 메서드는 공격 대상(`target`)을 매개변수로 받으며, 자신의 `power`만큼 대상의 `take_damage` 메서드를 호출하여 피해를 입힙니다.
5.  `heal` 메서드를 정의합니다.
    *   이 메서드는 `마력(mp)` 10을 소모하여 자신의 `체력(hp)`을 20만큼 회복시킵니다.
    *   `if` 문을 사용하여 `mp`가 10 이상일 때만 치유가 가능하도록 구현합니다. `mp`가 부족하면 치유에 실패했다는 메시지를 출력합니다.
    *   치유 후 `hp`가 `max_hp`를 초과할 경우, `hp`를 `max_hp` 값으로 조정합니다.
6.  `show_status` 메서드를 정의하여 `Hero`의 현재 `name`, `hp`, `mp`, `power`를 출력합니다.
7.  수업에서 작성한 `Monster` 클래스 코드를 그대로 가져와 사용합니다.
8.  `Hero` 객체 1개와 `Monster` 객체 1개를 생성한 후, 다음 순서대로 상호작용을 시뮬레이션합니다.
    *   영웅이 몬스터를 1회 공격합니다.
    *   몬스터가 영웅을 1회 공격합니다.
    *   영웅이 `heal` 메서드를 사용하여 스스로를 치유합니다.
    *   각 행동 이후, 두 객체의 상태를 `show_status` 메서드를 통해 확인합니다.

---

### **미션 풀이**

본 미션은 객체지향 프로그래밍의 핵심 개념인 클래스 정의, 속성 초기화, 메서드 구현, 그리고 객체 간의 상호작용을 종합적으로 실습하는 과정입니다. 아래 풀이 과정을 통해 문제 해결의 흐름을 파악할 수 있습니다.

#### **1. `Monster` 클래스 준비**

가장 먼저, `Hero`와 상호작용할 대상인 `Monster` 클래스가 필요합니다. 미션 요구 사항에 따라 수업에서 사용한 코드를 그대로 가져옵니다. 이 클래스는 이름, 체력, 공격력을 속성으로 가지며, 피해를 받는 `take_damage` 메서드와 상태를 출력하는 `show_status` 메서드를 포함합니다.

#### **2. `Hero` 클래스 정의 및 `__init__` 메서드 구현**

다음으로 `Hero` 클래스를 정의합니다. 객체가 생성될 때 필요한 초기 값들을 설정하기 위해 `__init__` 생성자 메서드를 구현합니다.

*   `name`, `hp`, `mp`, `power`를 매개변수로 받아 각각 `self.name`, `self.hp` 등으로 객체의 속성에 저장합니다.
*   요구 사항에 따라, 치유 시 최대 체력을 넘지 않도록 하기 위해 초기 `hp` 값을 `self.max_hp` 라는 새로운 속성에 별도로 저장합니다.

#### **3. `attack` 메서드 구현**

`Hero`가 다른 객체를 공격하는 기능을 `attack` 메서드로 구현합니다.

*   공격할 대상(`target`)을 매개변수로 받습니다.
*   `target` 객체가 가진 `take_damage` 메서드를 호출하여, `Hero` 자신의 공격력(`self.power`)만큼 피해를 입힙니다. 이 과정이 객체 간의 상호작용을 나타냅니다.

#### **4. `heal` 메서드 구현**

`Hero`가 자신의 체력을 회복하는 `heal` 메서드를 구현합니다. 이 메서드는 여러 조건 확인이 필요합니다.

*   `if` 문을 사용하여 `Hero`의 마력(`self.mp`)이 10 이상인지 먼저 확인합니다.
*   마력이 부족하면, 치유 실패 메시지를 출력하고 즉시 메서드를 종료합니다.
*   마력이 충분하다면, `self.mp`에서 10을 차감하고 `self.hp`에 20을 더합니다.
*   치유 후, `self.hp`가 `self.max_hp`를 초과했는지 다시 `if` 문으로 확인합니다.
*   만약 초과했다면, `self.hp` 값을 `self.max_hp` 값으로 재설정하여 최대 체력을 넘지 않도록 합니다.

#### **5. `show_status` 메서드 구현**

`Hero`의 현재 상태를 쉽게 확인할 수 있도록 `show_status` 메서드를 구현합니다. `f-string`을 사용하여 `name`, `hp`, `mp`, `power` 속성을 형식에 맞춰 출력합니다.

#### **6. 시뮬레이션 코드 작성**

클래스 정의가 완료되면, 실제 객체를 생성하여 시나리오를 실행합니다.

1.  `Hero` 클래스와 `Monster` 클래스의 인스턴스(객체)를 각각 생성합니다.
2.  요구 사항의 순서에 따라 각 객체의 메서드를 호출합니다.
    *   `hero.attack(monster)`: 영웅이 몬스터를 공격합니다.
    *   `monster.attack(hero)`: 몬스터가 영웅을 공격합니다.
    *   `hero.heal()`: 영웅이 스스로를 치유합니다.
3.  각 행동이 끝날 때마다 `hero.show_status()`와 `monster.show_status()`를 호출하여 변화된 상태를 확인합니다.

이러한 단계별 접근을 통해 복잡해 보이는 요구 사항을 체계적으로 해결할 수 있습니다.

#### **최종 전체 소스코드**

```python
# 1. 상호작용을 위한 Monster 클래스 (수업 내용)
class Monster:
    def __init__(self, name, hp, power):
        self.name = name
        self.hp = hp
        self.power = power

    def attack(self, target):
        print(f"{self.name}이(가) {target.name}을(를) 공격합니다!")
        target.take_damage(self.power)

    def take_damage(self, amount):
        self.hp -= amount
        print(f"{self.name}이(가) {amount}의 피해를 입었습니다. 현재 HP: {self.hp}")
        if self.hp <= 0:
            print(f"{self.name}이(가) 쓰러졌습니다.")

    def show_status(self):
        print(f"--- {self.name} 상태 ---")
        print(f"HP: {self.hp}")
        print(f"Power: {self.power}")
        print("--------------------")

# 2. 미션 요구사항에 따른 Hero 클래스 구현
class Hero:
    def __init__(self, name, hp, mp, power):
        self.name = name
        self.hp = hp
        self.mp = mp
        self.power = power
        self.max_hp = hp  # 최대 체력 값을 별도로 저장

    def attack(self, target):
        print(f"{self.name}이(가) {target.name}을(를) 공격합니다!")
        target.take_damage(self.power)

    def heal(self):
        if self.mp >= 10:
            self.mp -= 10
            heal_amount = 20
            self.hp += heal_amount
            
            # 최대 체력을 초과하지 않도록 검사
            if self.hp > self.max_hp:
                self.hp = self.max_hp
            
            print(f"{self.name}이(가) 마력 10을 사용하여 체력을 {heal_amount}만큼 회복했습니다.")
        else:
            print(f"{self.name}의 마력이 부족하여 치유에 실패했습니다.")

    def show_status(self):
        print(f"--- {self.name} 상태 ---")
        print(f"HP: {self.hp}/{self.max_hp}")
        print(f"MP: {self.mp}")
        print(f"Power: {self.power}")
        print("--------------------")

# 3. 객체 생성 및 시뮬레이션
hero = Hero("용사", 100, 30, 15)
monster = Monster("슬라임", 50, 10)

print("=== 초기 상태 ===")
hero.show_status()
monster.show_status()
print("\n")

print("=== 1. 영웅이 몬스터를 공격 ===")
hero.attack(monster)
hero.show_status()
monster.show_status()
print("\n")

print("=== 2. 몬스터가 영웅을 공격 ===")
monster.attack(hero)
hero.show_status()
monster.show_status()
print("\n")

print("=== 3. 영웅이 스스로를 치유 ===")
hero.heal()
hero.show_status()
monster.show_status()
print("\n")
```