# ====================================
# Part 4. 튜플 완전정복
# ====================================

# 튜플(Tuple): 수정할 수 없는 리스트와 유사한 자료구조입니다.
# 한번 생성되면 그 내용을 변경할 수 없는 '불변(Immutable)' 특성을 가집니다.

# 1. 튜플의 불변성(Immutability) 확인
print("--- 1. 튜플의 불변성(Immutability) ---")

# 수정 가능한 리스트는 요소의 값을 변경할 수 있습니다.
my_list = [1, 2, 3]
my_list[0] = 100
print(f"리스트 수정 후: {my_list}")

# 수정 불가능한 튜플은 요소의 값을 변경할 수 없습니다.
my_tuple = (1, 2, 3)
# my_tuple[0] = 100  # 이 코드의 주석을 해제하고 실행하면 TypeError가 발생합니다.
print(f"원본 튜플: {my_tuple}")
print("# 튜플의 요소를 변경하려고 하면 TypeError가 발생합니다.\n")


# 2. 튜플 생성 방법
print("--- 2. 튜플 생성 방법 ---")

# 가장 기본적인 방법은 소괄호()를 사용하여 생성하는 것입니다.
tuple1 = (1, 2, 3, 4, 5)
print(f"소괄호 사용: {tuple1}, 타입: {type(tuple1)}")

# 소괄호 없이 쉼표(,)로 데이터를 나열해도 튜플로 생성됩니다. (패킹)
tuple2 = 6, 7, 8
print(f"소괄호 미사용: {tuple2}, 타입: {type(tuple2)}\n")


# 3. 요소가 하나인 튜플 생성 시 주의점
print("--- 3. 요소가 하나인 튜플 ---")

# 쉼표가 없으면 일반적인 연산 우선순위 괄호로 인식되어 튜플이 아닌 정수(int)가 됩니다.
not_a_tuple = (10)
print(f"쉼표 없음: {not_a_tuple}, 타입: {type(not_a_tuple)}")

# 요소가 하나인 튜플을 만들려면 반드시 값 뒤에 쉼표(,)를 붙여야 합니다.
is_a_tuple = (10,)
print(f"쉼표 있음: {is_a_tuple}, 타입: {type(is_a_tuple)}\n")


# 4. 튜플의 주요 연산 및 메서드
print("--- 4. 튜플 연산 및 메서드 ---")

# 인덱싱(Indexing)과 슬라이싱(Slicing)은 리스트와 동일하게 사용 가능합니다.
print(f"첫 번째 요소: {tuple1[0]}")
print(f"슬라이싱 (2번 인덱스부터 끝까지): {tuple1[2:]}\n")

# 내용을 변경하지 않는 메서드는 사용 가능합니다.
test_tuple = ('a', 'b', 'c', 'a', 'a')

# .count(): 특정 값의 개수를 반환합니다.
print(f"'a'의 개수: {test_tuple.count('a')}")

# .index(): 특정 값의 첫 번째 위치(인덱스)를 반환합니다.
print(f"'c'의 위치: {test_tuple.index('c')}\n")


# 5. 튜플 순회 (Iteration)
print("--- 5. 튜플 순회 ---")
# for문을 사용하여 튜플의 모든 요소를 순서대로 접근할 수 있습니다.
for item in tuple1:
    print(item)
print("")


# 6. 패킹(Packing)과 언패킹(Unpacking)
print("--- 6. 패킹과 언패킹 ---")

# 패킹: 여러 개의 값을 하나의 변수(튜플)에 묶어서 담는 과정입니다.
screen_resolution = (1920, 1080)
print(f"패킹된 튜플: {screen_resolution}")

# 언패킹: 튜플의 각 요소를 여러 개의 변수에 나누어 할당하는 과정입니다.
# 튜플의 요소 개수와 할당할 변수의 개수가 정확히 일치해야 합니다.
width, height = screen_resolution
print(f"언패킹 결과 -> 너비: {width}, 높이: {height}\n")


# 7. 튜플의 활용: 딕셔너리 키
print("--- 7. 튜플의 딕셔너리 키 활용 ---")

# 불변(Immutable) 객체만 딕셔너리의 키가 될 수 있습니다.
# 따라서 튜플은 딕셔너리의 키로 사용될 수 있습니다.
skill_cooldowns = {
    ('전사', '베기'): 5,
    ('마법사', '화염구'): 8,
    ('전사', '강타'): 10
}

# 튜플을 키로 사용하여 값에 접근합니다.
cooldown = skill_cooldowns[('전사', '베기')]
print(f"전사 '베기' 스킬의 쿨타임: {cooldown}초")

# 리스트는 가변(Mutable) 객체이므로 딕셔너리 키로 사용할 수 없습니다.
# unhashable_dict = {['전사', '베기']: 5} # 이 코드는 TypeError: unhashable type: 'list' 오류를 발생시킵니다.


'''
    - 정리하며
        1. 튜플의 핵심은 '불변성(Immutable)'입니다. 생성 후에는 요소의 추가, 삭제, 변경이 불가능하여 데이터의 안정성을 보장합니다.
        2. 소괄호()로 생성하며, 요소가 하나일 때는 반드시 값 뒤에 쉼표(,)를 붙여야 튜플로 인식됩니다. (e.g., (10,))
        3. 인덱싱, 슬라이싱, 순회 등 데이터를 읽는 연산은 리스트와 동일하게 가능합니다.
        4. .count(), .index()와 같이 내용을 변경하지 않는 메서드는 제공됩니다.
        5. 여러 값을 하나로 묶는 '패킹'과, 묶음을 여러 변수로 푸는 '언패킹'은 매우 실용적인 기능입니다.
        6. 불변성을 가지기 때문에, 리스트와 달리 딕셔너리의 키(key)로 사용될 수 있습니다. 이는 튜플의 중요한 활용 사례입니다.
'''