# ====================================
# Part 8. 스페셜(던더,매직) 메서드
# ====================================

# Dog 클래스를 정의합니다.
# __init__, __str__, __len__, __del__ 과 같은 스페셜 메서드와
# 이름 맹글링이 적용되는 __secret_note 속성을 포함합니다.
class Dog:
    def __init__(self, name, breed, weight):
        self.name = name
        self.breed = breed
        self.weight = weight
        self.__secret_note = "이 강아지는 사실 천재다."
        # __init__은 객체 생성 시점에 자동으로 호출됩니다.

    def __str__(self):
        # print() 함수 등으로 객체를 문자열로 표현해야 할 때 호출됩니다.
        # 사용자가 객체를 쉽게 이해할 수 있는 '문자열'을 반환해야 합니다.
        return f"이름: {self.name}, 품종: {self.breed}, 몸무게: {self.weight}kg"

    def __len__(self):
        # len() 함수로 객체의 길이를 조회할 때 호출됩니다.
        # 이 예제에서는 강아지의 '길이' 개념을 '몸무게'로 정의합니다.
        # 정수(integer)를 반환해야 합니다.
        return self.weight

    def __del__(self):
        # 객체가 메모리에서 소멸되기 직전에 호출됩니다.
        # 객체를 가리키는 모든 참조(이름표)가 사라졌을 때 실행됩니다.
        print(f"{self.name} 객체가 소멸됩니다.")


# --- 1. __str__ 메서드 테스트 ---
print("--- 1. __str__ 메서드 테스트 ---")
# Dog 객체(인스턴스)를 생성합니다.
poppy = Dog("뽀삐", "말티즈", 5)

# __str__ 메서드가 없다면, print(poppy)는 <...Dog object at 0x...> 와 같은 메모리 주소를 출력합니다.
# __str__ 메서드를 정의했기 때문에, 해당 메서드가 반환하는 문자열이 출력됩니다.
print(poppy)
print("\n")


# --- 2. __len__ 메서드 테스트 ---
print("--- 2. __len__ 메서드 테스트 ---")
# __len__ 메서드가 없다면, len(poppy)는 TypeError를 발생시킵니다.
try:
    # 아래 코드를 테스트하려면 클래스에서 __len__ 메서드를 주석 처리해야 합니다.
    # len(poppy)
    pass
except TypeError as e:
    print(f"에러 발생: {e}")

# __len__을 정의했으므로, 몸무게 값이 반환됩니다.
print(f"강아지의 길이(몸무게): {len(poppy)}")
print("\n")


# --- 3. 이름 맹글링(Name Mangling) 테스트 ---
print("--- 3. 이름 맹글링(Name Mangling) 테스트 ---")
# __(언더스코어 두 개)로 시작하는 속성은 외부에서 직접 접근할 수 없습니다.
try:
    print(poppy.__secret_note)
except AttributeError as e:
    print(f"에러 발생: {e}")

# 파이썬은 내부적으로 이름을 _클래스이름__속성이름 형태로 변경하여 관리합니다.
# 이름 맹글링은 상속 시 발생할 수 있는 속성 이름 충돌을 방지하기 위한 기능입니다.
# 변경된 이름으로는 접근이 가능하지만, 이는 권장되지 않는 방법입니다.
print(f"변경된 이름으로 접근: {poppy._Dog__secret_note}")
print("\n")


# --- 4. __del__ 메서드 테스트 ---
print("--- 4. __del__ 메서드 테스트 ---")
# del 키워드는 객체를 직접 삭제하는 것이 아니라, 객체를 가리키는 변수(이름표)를 삭제합니다.
# poppy 변수를 삭제하면, Dog 객체를 가리키는 이름표가 모두 사라지므로
# 파이썬의 가비지 컬렉터가 객체를 메모리에서 제거하고, 이 때 __del__이 호출됩니다.
print("poppy 변수 삭제 시도...")
del poppy
print("poppy 변수가 삭제되었습니다.")
print("\n")

# poppy 라는 이름이 삭제되었으므로, 더는 접근할 수 없어 NameError가 발생합니다.
print("--- 삭제된 변수 접근 시도 ---")
try:
    print(poppy)
except NameError as e:
    print(f"에러 발생: {e}")


'''
    - 정리하며
        1. 스페셜 메서드는 우리가 직접 호출하는 것이 아니라, print(), len() 등 특정 상황에서 파이썬에 의해 자동으로 호출되는 메서드입니다.
        2. __init__: 객체가 생성될 때 호출됩니다.
        3. __str__: 객체를 문자열로 표현해야 할 때 (예: print() 함수) 호출됩니다.
        4. __len__: 객체의 길이를 구해야 할 때 (예: len() 함수) 호출됩니다.
        5. __del__: 객체가 메모리에서 소멸될 때 호출됩니다.
        6. 이름 맹글링: __속성명 처럼 언더스코어 두 개로 시작하는 속성은 외부에서의 직접 접근을 막기 위해 파이썬이 내부적으로 _클래스명__속성명으로 이름을 변경합니다.
        7. 클래스에 스페셜 메서드를 구현하면, 직접 만든 객체를 파이썬의 기본 자료형처럼 자연스럽게 다룰 수 있습니다.
'''