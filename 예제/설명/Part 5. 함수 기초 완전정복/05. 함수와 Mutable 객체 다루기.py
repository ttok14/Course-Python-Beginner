# ====================================
# Part 5. 함수와 Mutable 객체 다루기
# ====================================

# 함수에 리스트, 딕셔너리와 같은 '변경 가능한(Mutable)' 객체를 전달할 때 발생하는
# 주요 현상과 이를 안전하게 다루는 방법을 학습합니다.


# 1. 함수의 부작용 (Side Effect) 확인하기
# ----------------------------------------------------
# 부작용: 함수가 자신의 스코프(범위)를 벗어나 외부에 있는 변수나 상태를
# 의도치 않게 변경하는 현상을 의미합니다.
print("--- 1. 함수의 부작용 (Side Effect) ---")

numbers_original = [10, 20, 30]

def modify_list(a_list):
    # 함수 내부에서 인자로 받은 리스트에 요소를 추가합니다.
    print(f"  (함수 안) 수정 전 리스트: {a_list}")
    a_list.append(99)
    print(f"  (함수 안) 수정 후 리스트: {a_list}")

print(f"함수 호출 전 원본: {numbers_original}")
modify_list(numbers_original) # 함수에 원본 리스트를 전달합니다.
print(f"함수 호출 후 원본: {numbers_original}") # 원본 리스트가 변경되었습니다.

print("\n" + "="*50 + "\n")


# 2. 참조 전달(Pass by Reference) 증명하기
# ----------------------------------------------------
# 파이썬은 함수에 인자를 전달할 때, 데이터의 복사본이 아닌
# 데이터가 저장된 메모리 주소의 '참조'를 전달합니다.
# id() 함수를 통해 이를 확인할 수 있습니다.
print("--- 2. id()로 참조 전달 증명하기 ---")

numbers_for_id_check = [10, 20, 30]

def check_id(a_list):
    # 함수 내부에서 인자로 받은 객체의 메모리 주소(id)를 확인합니다.
    print(f"  (함수 안) 전달받은 인자의 ID: {id(a_list)}")

# 함수 외부에서 원본 객체의 id를 확인합니다.
print(f"함수 호출 전 원본의 ID: {id(numbers_for_id_check)}")
# 함수를 호출합니다.
check_id(numbers_for_id_check)
# 두 ID 값이 동일하게 출력되어, 함수 안과 밖의 변수가
# 정확히 동일한 리스트 객체를 가리키고 있음을 증명합니다.

print("\n" + "="*50 + "\n")


# 3. 방어적 복사 (Defensive Copy)로 부작용 해결하기
# ----------------------------------------------------
# 원본 데이터를 보호하기 위해, 함수 내부에서 데이터의 복사본을 만들어 사용하는 기법입니다.
# 이를 통해 부작용을 원천적으로 차단할 수 있습니다.
print("--- 3. 방어적 복사로 부작용 해결하기 ---")

def modify_list_safe(a_list):
    # .copy() 메서드를 사용해 원본 리스트의 '얕은 복사본'을 생성합니다.
    new_list = a_list.copy()
    new_list.append(99)
    # 수정된 복사본을 반환합니다.
    return new_list

numbers_to_protect = [10, 20, 30]

print(f"함수 호출 전 원본: {numbers_to_protect}")
# 함수가 반환한 새로운 리스트를 'result' 변수에 저장합니다.
result = modify_list_safe(numbers_to_protect)

print(f"함수 호출 후 원본: {numbers_to_protect}") # 원본은 변경되지 않았습니다.
print(f"함수가 반환한 결과: {result}")

print("\n" + "="*50 + "\n")


# 4. 가장 위험한 함정: Mutable 기본값
# ----------------------------------------------------
# 함수의 기본값으로 리스트나 딕셔너리를 사용하면 심각한 버그가 발생할 수 있습니다.
# 기본값 객체는 함수가 '정의'될 때 단 한 번만 생성되고, 모든 함수 호출에서 공유됩니다.
print("--- 4. Mutable 기본값의 함정 ---")

def add_to_list_buggy(value, target=[]):
    # 기본값으로 사용된 리스트 객체는 모든 호출에 걸쳐 재사용됩니다.
    target.append(value)
    print(f"  ID: {id(target)}, 현재 리스트: {target}")

print("첫 번째 호출:")
add_to_list_buggy(1) # target 인자를 주지 않았으므로 기본값 []가 사용됩니다.

print("-" * 20)

print("두 번째 호출:")
add_to_list_buggy(2) # 새로운 리스트가 아닌, 이전 호출에서 사용된 리스트가 다시 사용됩니다.
# ID 값이 동일하게 출력되는 것을 통해 이를 확인할 수 있습니다.

print("\n" + "="*50 + "\n")


# 5. 올바른 기본값 사용 패턴: None 패턴
# ----------------------------------------------------
# Mutable 객체를 기본값으로 사용해야 할 때는, 기본값을 None으로 지정하고
# 함수 내부에서 'if OOO is None:' 패턴으로 새 객체를 생성하는 것이 표준적인 해결책입니다.
print("--- 5. 올바른 기본값 사용 패턴 (None 패턴) ---")

def add_to_list_safe(value, target=None):
    # 함수가 호출될 때마다 target이 None인지 확인합니다.
    if target is None:
        # target이 None이면, 새로운 빈 리스트를 생성하여 할당합니다.
        target = []
    
    target.append(value)
    print(f"  ID: {id(target)}, 현재 리스트: {target}")

print("첫 번째 호출:")
add_to_list_safe(1) # target이 None이므로 새 리스트가 생성됩니다.

print("-" * 20)

print("두 번째 호출:")
add_to_list_safe(2) # target이 None이므로 또 다른 새 리스트가 생성됩니다.
# 각 호출마다 ID 값이 다른 것을 통해, 매번 독립적인 객체가 생성되었음을 알 수 있습니다.


'''
    - 정리하며
        1. [부작용] 함수에 리스트, 딕셔너리 같은 Mutable 객체를 전달하면, 함수 내부의 수정이 원본에 영향을 줄 수 있습니다.
        2. [원인] 이는 파이썬이 데이터를 복사해서 넘기는 것이 아니라, 원본 데이터의 메모리 주소(참조)를 전달하기 때문입니다.
        3. [해결책 1] 원본을 보호하려면, 함수 안에서 .copy() 메서드로 '방어적 복사'를 수행하여 복사본을 만들어 사용해야 합니다.
        4. [함정] 함수의 기본값으로 리스트나 딕셔너리(Mutable)를 사용하면, 해당 객체는 모든 호출에서 공유되어 예기치 않은 버그를 유발합니다.
        5. [해결책 2] 안전한 기본값 사용을 위해 '...=None'으로 기본값을 설정하고, 함수 내부에서 'if ... is None:' 구문을 통해 새 객체를 생성하는 패턴을 사용해야 합니다.
'''